%prefix "parser"               # Define the parser prefix

%value "std::unique_ptr<node>"  # Return unique_ptr for node management

%auxil "manager_t *"            # For parser context

%header {
#include "symbol_enum.h"
#include "node.h"
#include <memory>
#include <vector>
#include <iostream>

typedef struct {
    const char *input;  // Input buffer
    size_t pos;         // Current position in the buffer
} manager_t;
}

%source {
#include <iostream>

using namespace std;

#define PCC_GETCHAR(auxil) get_character(auxil)
#define PCC_BUFFERSIZE 1024

// Custom function to get one character at a time
static int get_character(manager_t *ctx) {
    if (ctx->input[ctx->pos] != '\0') {
        return ctx->input[ctx->pos++];  // Return the next character
    }
    return -1;  // End of input (EOF)
}

}

statement
  <- _ formula:Formula _ EOL { $$ = std::move(formula); }
   / ( !EOL . )* EOL { cout << "Syntax error!" << endl; $$ = nullptr; }

Formula
  <- EqualPredicate

EqualPredicate
  <- t1:Term _ e:EQUALS _ t2:Term {
      std::vector<std::unique_ptr<node>> children;
      children.push_back(std::move(t1));
      children.push_back(std::move(t2));
      $$ = std::make_unique<node>(SYMBOL_EQUALS, node::APPLICATION, std::move(children));
  }

Term
  <- Variable

TOP
  <- '\\top' { $$ = std::make_unique<node>(SYMBOL_TOP, node::CONSTANT); }

BOT
  <- '\\bot' { $$ = std::make_unique<node>(SYMBOL_BOT, node::CONSTANT); }

CAP
  <- '\\cap' { $$ = std::make_unique<node>(SYMBOL_CAP, node::BINARY_OP); }

CUP
  <- '\\cup' { $$ = std::make_unique<node>(SYMBOL_CUP, node::BINARY_OP); }

SETMINUS
  <- '\\setminus' { $$ = std::make_unique<node>(SYMBOL_SETMINUS, node::BINARY_OP); }

TIMES
  <- '\\times' { $$ = std::make_unique<node>(SYMBOL_TIMES, node::BINARY_OP); }

POWERSET
  <- '\\powerset' { $$ = std::make_unique<node>(SYMBOL_POWERSET, node::UNARY_OP); }

FORALL
  <- '\\forall' { $$ = SYMBOL_FORALL; }

EXISTS
  <- '\\exists' { $$ = SYMBOL_EXISTS; }

SUBSET
  <- '\\subset' { $$ = std::make_unique<node>(SYMBOL_SUBSET, node::BINARY_OP); }

SUBSETEQ
  <- '\\subseteq' { $$ = std::make_unique<node>(SYMBOL_SUBSETEQ, node::BINARY_OP); }

EQUALS
  <- '=' { $$ = std::make_unique<node>(SYMBOL_EQUALS, node::BINARY_OP); }

NEG
  <- '\\neg' { $$ = std::make_unique<node>(SYMBOL_NOT, node::UNARY_OP); }

AND
  <- '\\wedge' { $$ = std::make_unique<node>(SYMBOL_AND, node::BINARY_OP); }

OR
  <- '\\vee' { $$ = std::make_unique<node>(SYMBOL_OR, node::BINARY_OP); }

OPEN
  <- '('

CLOSE
  <- ')'

DOT
  <- '.'

COMMA
  <- ','

Variable
  <- [a-zA-Z] [a-zA-Z0-9_]* { $$ = std::make_unique<node>(std::string($0)); }

_
  <- [ \t]*

EOL
  <- '\n' / '\r\n' / '\r'

%%

// Main function for the parser
int main(int argc, char** argv) {
    manager_t mgr;
    std::string input;

    {
        parser_context_t *ctx = parser_create(&mgr);
        std::unique_ptr<node> ast = nullptr;

        std::cout << "> ";

        while (getline(std::cin, input)) {
            input.push_back('\n');  // Add a newline at the end of input

            // Set the input buffer and reset position
            mgr.input = input.c_str();
            mgr.pos = 0;
            
            parser_parse(ctx, &ast);

            if (ast) {
                ast->print();
                ast.reset();  // Automatically free the memory
            }

            std::cout << "> ";
        }

        std::cout << std::endl;

        parser_destroy(ctx);
    }

    return 0;
}
