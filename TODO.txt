Critical:

* When moving to next target, must select assumptions that haven't been proved for
  that target yet

* When selecting targets, activate only those hyps whose assumptions are a subset
  of an unproved set of assumptions for current leaf hydra

* When adding new target, update restrictions of all hyps that could be used to
  prove the old target, to indicate that it can also be used to prove the new
  target

* Currently only the leaf hydra can be proved. Allow all hydras on the current_hydra
  path to be checked for completion, and delete all descendants when proved and
  update the proved field of all descendants otherwise

* Check for tautologies in check_done

* Put assumptions/restrictions debugging code in print_tableau

* Split iff's

* Factor out dealing with restrictions/assumptions in moves by making functions that
  deal with tablines, e.g. copy_restrictions, combine_restrictions, etc.

* Should targets have restrictions/assumptions?

* Make checking moves (e.g. check_restrictions/assumptions) optional, so this doesn't
  duplicate work automation will be doing before executing the moves

* Should skolem functions be renamed to prevent capture in modus_ponens?
  What about non-skolem functions?

* Add special implication-to-disjunction case to modus_ponens.

* Deal with modus ponens case where single unit clause is a disjunction.

* Add split_disjunction move (split tableau)

Eventually:

* Splitting on disjunctions sharing variables. Requires backtracking of proved
  targets that wont unify on both branches of the assumption tree

Noncritical:

* Modify parser error to show position in string where error occurs with arrow
  pointing

* Allow user to enter hypotheses and targets manually

* print/parse \not\subseteq and \not\leq (the latter can't be made into > in general,
  e.g. partial orders), and \neg(A \subseteq B), \neg(a \leq b), etc. Must internally
  canonicalise to \neg(blah) for negated literal purposes for resolution

* Helpful error messages in parser (i.e. rules corresponding to non-matching inputs)

Maybe:
