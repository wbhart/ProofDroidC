Critical:

* Set 3 requires library backwards reasoning

* Proved 1-14, 19, 22-25, 34, 41-47

* Set 15-18, 20-21, 26-27, 29-33, 35-40 loops

* Set 28 not proved

* Set 1 leaks

* We don't need to compute tarc and tabc for level 2 and 3

* In print_tableau, only print restrictions that correspond to active targets

* Investigate why set2 causes x to unify with itself. Renaming issue?

* Don't just hard code ("set") module loading in automatic move

* For library forwards and backwards reasoning, filter theorems for tabc/tarc first

* Do we need to remove renamed vars from used_vars after a failed move?

* Currently only the leaf hydra can be proved. Allow all hydras on the current_hydra
  path to be checked for completion, and delete all descendants when proved and
  update the proved field of all descendants otherwise

* Check for tautologies in check_done

* Factor out dealing with restrictions/assumptions in moves by making functions that
  deal with tablines, e.g. copy_restrictions, combine_restrictions, etc.

* Should targets have restrictions/assumptions? Yes, they could have been reasoned
  backwards to from other targets and hypotheses that have assumptions.

* When moving to next target, must select assumptions that haven't been proved for
  that target yet

* Make checking moves (e.g. check_restrictions/assumptions) optional, so this doesn't
  duplicate work automation will be doing before executing the moves

* Should skolem functions be renamed to prevent capture in modus_ponens?
  What about non-skolem functions?

* Add special implication-as-disjunction case to modus_ponens.

* Deal with modus ponens case where single unit clause is a disjunction.

Eventually:

* Splitting on disjunctions sharing variables. Requires backtracking of proved
  targets that wont unify on both branches of the assumption tree

Noncritical:

* Modify parser error to show position in string where error occurs with arrow
  pointing

* Allow user to enter hypotheses and targets manually

* print/parse \not\subseteq and \not\leq (the latter can't be made into > in general,
  e.g. partial orders), and \neg(A \subseteq B), \neg(a \leq b), etc. Must internally
  canonicalise to \neg(blah) for negated literal purposes for resolution

* Helpful error messages in parser (i.e. rules corresponding to non-matching inputs)

Maybe:
