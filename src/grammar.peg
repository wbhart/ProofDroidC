%prefix "parser"               # Define the parser prefix

%value "node*"                 # Set the return type for the parser actions (node*)

%auxil "manager_t *"           # For parser context

%header {
#include "symbol_enum.h"
#include "node.h"
#include <string>
#include <iostream>
#include <vector>

typedef struct {
    const char *input;  // Input buffer
    size_t pos;         // Current position in the buffer
} manager_t;
}

%source {
#include <iostream>

using namespace std;

#define PCC_GETCHAR(auxil) get_character(auxil)
#define PCC_BUFFERSIZE 1024

// Custom function to get one character at a time
static int get_character(manager_t *ctx) {
    if (ctx->input[ctx->pos] != '\0') {
        return ctx->input[ctx->pos++];  // Return the next character
    }
    return -1;  // End of input (EOF)
}
}

statement
  <- _ formula:Formula _ EOL { $$ = formula; }
   / ( !EOL . )* EOL { cout << "Syntax error!" << endl; $$ = nullptr; }

Formula
  <- e:EqualPredicate { $$ = e; }

EqualPredicate
  <- t1:Term _ e:EQUALS _ t2:Term {
        std::vector<node*> children;
        children.push_back(e);  // Push the EQUALS operator node (already parsed as a BINARY_OP)
        children.push_back(t1);  // Push the first term
        children.push_back(t2);  // Push the second term
        $$ = new node(node::APPLICATION, children);  // Create an APPLICATION node
    }

Term
  <- t:Application { $$ = t; }
   / t:UnaryOp { $$ = t; }
   / t:Variable { $$ = t; }

Application
  <- i:Variable _ OPEN _ args:TermList _ CLOSE {
        std::vector<node*> children = args->children;  // Extract children from TermList
        children.insert(children.begin(), i);  // Insert the function/variable name at the start
        
        // Clear the args node's children to prevent it from deleting them
        args->children.clear();
        
        $$ = new node(node::APPLICATION, children);  // Initialize the APPLICATION node after modifying children
        
        delete args;  // Clean up the args node after extracting its children
    }

UnaryOp
  <- p:POWERSET _ OPEN _ t:Term _ CLOSE {
        std::vector<node*> children;
        children.push_back(new node(node::UNARY_OP, SYMBOL_POWERSET));  // First child: powerset operator
        children.push_back(t);  // Second child: the argument (e.g., S)
        $$ = new node(node::APPLICATION, children);  // Create an APPLICATION node
    }

TermList
  <- head:Term {
        $$ = new node(node::TUPLE, std::vector<node*>());  // Initialize an empty vector
        $$->children.push_back(head);  // Add the head term to the children
    }
    (_ COMMA _ t:Term { $$->children.push_back(t); })*

TOP
  <- '\\top' { $$ = new node(node::CONSTANT, SYMBOL_TOP); }

BOT
  <- '\\bot' { $$ = new node(node::CONSTANT, SYMBOL_BOT); }

CAP
  <- '\\cap' { $$ = new node(node::BINARY_OP, SYMBOL_CAP); }

CUP
  <- '\\cup' { $$ = new node(node::BINARY_OP, SYMBOL_CUP); }

SETMINUS
  <- '\\setminus' { $$ = new node(node::BINARY_OP, SYMBOL_SETMINUS); }

TIMES
  <- '\\times' { $$ = new node(node::BINARY_OP, SYMBOL_TIMES); }

POWERSET
  <- '\\mathcal{P}' { $$ = new node(node::UNARY_OP, SYMBOL_POWERSET); }

FORALL
  <- '\\forall' { $$ = SYMBOL_FORALL; }

EXISTS
  <- '\\exists' { $$ = SYMBOL_EXISTS; }

SUBSET
  <- '\\subset' { $$ = new node(node::BINARY_OP, SYMBOL_SUBSET); }

SUBSETEQ
  <- '\\subseteq' { $$ = new node(node::BINARY_OP, SYMBOL_SUBSETEQ); }

EQUALS
  <- '=' { $$ = new node(node::BINARY_OP, SYMBOL_EQUALS); }

NEG
  <- '\\neg' { $$ = new node(node::UNARY_OP, SYMBOL_NOT); }

AND
  <- '\\wedge' { $$ = new node(node::BINARY_OP, SYMBOL_AND); }

OR
  <- '\\vee' { $$ = new node(node::BINARY_OP, SYMBOL_OR); }

OPEN
  <- '('

CLOSE
  <- ')'

COMMA
  <- ','

Variable
  <- [a-zA-Z] [a-zA-Z0-9_]* { $$ = new node(node::VARIABLE, std::string($0)); }

_
  <- [ \t]*  # Whitespace

EOL
  <- '\n' / '\r\n' / '\r'

